name: "Tauri Windows Auto Release"

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  actions: read

env:
  TAURI_FILE: src-tauri/tauri.conf.json
  OUT_DIR: src-tauri/target/release/bundle
  MSI_DIR: src-tauri/target/release/bundle/msi
  NODE_VERSION: 20
  RUST_TOOLCHAIN: stable

jobs:
  prepare-environment:
    runs-on: ubuntu-22.04
    outputs:
      next_version: ${{ steps.calculate.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: sudo apt-get install -y jq

      - name: Validate commit messages
        run: |
          npx commitlint --from=$(git describe --tags --abbrev=0 || echo "") --to=HEAD || true
        shell: bash

      - id: calculate
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          RANGE=${PREV_TAG:+$PREV_TAG..HEAD}
          if git log $RANGE --pretty=%B | grep -q "BREAKING CHANGE"; then TYPE="major"
          elif git log $RANGE --pretty=%B | grep -q "^feat:"; then TYPE="minor"
          elif git log $RANGE --pretty=%B | grep -q "^fix:"; then TYPE="patch"
          else TYPE="patch"; fi

          OLD_VERSION=$(jq -r '.version' $TAURI_FILE)
          if [ -z "$OLD_VERSION" ] || [ "$OLD_VERSION" = "null" ]; then
            echo "‚ùå Version not found in $TAURI_FILE"
            exit 1
          fi

          IFS='.' read -r MAJOR MINOR PATCH <<< "$OLD_VERSION"

          case "$TYPE" in
            major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR+1)); PATCH=0 ;;
            patch) PATCH=$((PATCH+1)) ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "Calculated new version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

  build-and-sign:
    needs: prepare-environment
    runs-on: windows-latest
    env:
      VERSION: ${{ needs.prepare-environment.outputs.next_version }}
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_TOOLCHAIN }}

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            node_modules
          key: ${{ runner.os }}-deps-${{ hashFiles('**/package-lock.json', '**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-deps-

      - name: Install dependencies (ci with fallback)
        shell: pwsh
        run: |
         npm i

      - name: Clean previous builds
        shell: pwsh
        run: |
          Remove-Item -Path "src-tauri/target" -Recurse -Force -ErrorAction SilentlyContinue

      - name: Update version in tauri.conf.json
        shell: pwsh
        run: |
          $content = Get-Content $env:TAURI_FILE -Raw | ConvertFrom-Json
          $content.version = "$env:VERSION"
          $content | ConvertTo-Json -Depth 10 | Set-Content $env:TAURI_FILE -Encoding utf8

      - name: Build with Tauri
        shell: pwsh
        run: npx tauri build

      - name: Sign MSI if key is available
        if: ${{ env.TAURI_SIGNING_PRIVATE_KEY != '' }}
        shell: pwsh
        run: |
          Write-Host "üîë Signing MSI..."
          $privateKey = "$env:TAURI_SIGNING_PRIVATE_KEY"
          $pwd = "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD"
          $decodedPassword = if ($pwd) { $pwd } else { "" }
          $privateKey | Out-File private.key -Encoding ascii
          $msi = Get-ChildItem -Path "$env:MSI_DIR" -Filter "*.msi" | Select-Object -First 1
          if (-not $msi) { exit 1 }
          npx tauri signer sign --private-key private.key --password "$decodedPassword" --version "$env:VERSION" --files "$($msi.FullName)" --output-dir "$env:OUT_DIR"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tauri-windows
          path: ${{ env.OUT_DIR }}

  release:
    needs: build-and-sign
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.prepare-environment.outputs.next_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: tauri-windows
          path: ./bundle

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "v${{ env.VERSION }}"
          release_name: "Release v${{ env.VERSION }}"
          draft: false
          prerelease: false
          body: "Automatically generated release for version v${{ env.VERSION }}"

      - name: Find MSI path
        id: msi
        run: |
          set -e
          MSI=$(ls ./bundle/msi/*.msi | head -n 1)
          if [ -z "$MSI" ]; then
            echo "No MSI found under ./bundle/msi"
            exit 1
          fi
          echo "path=$MSI" >> $GITHUB_OUTPUT

      - name: Upload MSI to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.msi.outputs.path }}
          asset_name: "app-v${{ env.VERSION }}.msi"
          asset_content_type: application/octet-stream

  bump-version:
    needs: release
    if: ${{ needs.release.result == 'success' }}
    runs-on: ubuntu-latest
    env:
      TAURI_FILE: src-tauri/tauri.conf.json
      VERSION: ${{ needs.prepare-environment.outputs.next_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up git
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

      - name: Generate changelog
        id: changelog
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          RANGE=${PREV_TAG}..HEAD
          if [ -z "$PREV_TAG" ]; then
            echo "No previous tag found. Generating full commit log."
            RANGE=""
          fi
          echo "Generating changelog from $RANGE"
          git log $RANGE --pretty=format:"- %s (%h)" > changelog.txt
          cat changelog.txt
          echo "CHANGELOG<<EOF" >> $GITHUB_ENV
          cat changelog.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Update version in tauri.conf.json
        run: |
          echo "üîß Updating version in $TAURI_FILE"
          jq ".version = \"${VERSION}\"" $TAURI_FILE > tmp.json && mv tmp.json $TAURI_FILE

      - name: Commit version bump and changelog
        run: |
          git add $TAURI_FILE changelog.txt || true
          git commit -m "chore: bump version to v${VERSION}" || echo "No changes to commit"

      - name: Create and push tag
        run: |
          TAG="v${VERSION}"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists!"
            exit 1
          fi
          git tag "$TAG"
          git push origin "$TAG"

      - name: Push version bump commit
        run: |
          git push origin main

      - name: Display changelog
        run: |
          echo "üìù Changelog for v${VERSION}:"
          cat changelog.txt
